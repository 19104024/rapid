#include "Problem.hpp"

#include <iostream>
#include <cassert>
#include <ctime>

#include "Output.hpp"
#include "Options.hpp"

namespace logic {
    
    std::ostream& operator<<(std::ostream& ostr, const std::vector<std::shared_ptr<const ProblemItem>>& f){ostr << "not implemented"; return ostr;}

    void ReasoningTask::outputSMTLIB(std::ostream& ostr) const
    {
        auto smtlibLogic = "UFDTLIA"; // uninterpreted functions, datatypes and linear integer arithmetic
        
        // if encoding is used as smtlib-benchmark, add meta information
        if(util::Configuration::instance().generateBenchmark().getValue())
        {
            ostr << "(set-info :smt-lib-version 2.6)\n";
            ostr << "(set-logic " << smtlibLogic << ")\n";

            std::time_t t = std::time(0);
            std::tm* now = std::localtime(&t);

            ostr << "(set-info :source |\n"
            << "Generated by: Bernhard Gleiss\n"
            << "Generated on: "
            << (now->tm_year + 1900) << "-"
            << (now->tm_mon + 1) << "-"
            << now->tm_mday << "\n"
            << "Generator: Rapid\n"
            << "Application: Software Verification\n"
            << "Target solver: Vampire\n"
            << "|)\n"
            << "(set-info :license \"https://creativecommons.org/licenses/by/4.0/\")\n"
            << "(set-info :category crafted)\n"
            << "(set-info :status unknown)\n\n";
        }
        else
        {
            ostr << "\n(set-logic " << smtlibLogic << ")\n\n";
        }
        
        // output sort declarations
        for(const auto& pair : Sorts::nameToSort())
        {
            ostr << declareSortSMTLIB(*pair.second);
        }
        
        // output symbol definitions
        for (const auto& pairStringSymbol : Signature::signature())
        {
            ostr << pairStringSymbol.second->declareSymbolSMTLIB();
        }
        
        // output each axiom
        for (const auto& axiom : axioms)
        {
            if (axiom->name != "")
            {
                ostr << "\n; Axiom: " << axiom->name;
            }
            ostr << "\n(assert\n" << axiom->formula->toSMTLIB(3) + "\n)\n";
        }
        
        // output conjecture
        assert(conjecture != nullptr);
        
        // if benchmark is used as smtlib-benchmark, replace (assert-not F) by (assert (not F))
        if(util::Configuration::instance().generateBenchmark().getValue())
        {
            ostr
            << "\n; negated conjecture\n"
            << "(assert\n"
            << "   (not\n"
            <<         conjecture->formula->toSMTLIB(6) << "\n"
            << "   )\n"
            << ")\n";
        }
        else
        {
            if (conjecture->name != "")
            {
                ostr << "\n; Conjecture: " << conjecture->name;
            }
            ostr << "\n(assert-not\n" << conjecture->formula->toSMTLIB(3) + "\n)\n";
        }

        ostr << "\n(check-sat)\n" << std::endl;
    }
    
    std::vector<const ReasoningTask> Problem::generateReasoningTasks() const
    {
        std::vector<const ReasoningTask> tasks;
        std::vector<std::shared_ptr<const Axiom>> currentAxioms;
        for (const auto& item : items)
        {
            if (item->type == ProblemItem::Type::Axiom)
            {
                auto castedItem = std::dynamic_pointer_cast<const Axiom>(item);
                currentAxioms.push_back(castedItem);
            }
         
            // if the item is a lemma or conjecture, generate a new reasoning task to prove that lemma/conjecture
            if (item->type == ProblemItem::Type::Lemma || item->type == ProblemItem::Type::Conjecture)
            {
                auto conjecture = std::make_shared<Conjecture>(item->formula, item->name);
                auto task = ReasoningTask(currentAxioms, conjecture);
                tasks.push_back(task);
            }
            
            // after generating a task to prove the lemma, the lemma can be used as axiom
            if (item->type == ProblemItem::Type::Lemma)
            {
                currentAxioms.push_back(std::make_shared<Axiom>(item->formula, "already-proven-lemma " + item->name));
            }
        }
        
        return tasks;
    }

}
